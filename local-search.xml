<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>四元数笔记</title>
    <link href="/2025/07/11/%E5%9B%9B%E5%85%83%E6%95%B0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/07/11/%E5%9B%9B%E5%85%83%E6%95%B0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>罗德里格斯公式</title>
    <link href="/2025/06/20/%E7%BD%97%E5%BE%B7%E9%87%8C%E6%A0%BC%E6%96%AF%E5%85%AC%E5%BC%8F/"/>
    <url>/2025/06/20/%E7%BD%97%E5%BE%B7%E9%87%8C%E6%A0%BC%E6%96%AF%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>本文主旨是便于理解公式的大致原理和使用过程，其中数学推导可能有诸多不严谨的地方，希望多多包涵以及批评指正</p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p><img src="/image/rod_image_0.png" alt="alt text"><br>看到题目的第一反应，是按照类似平移的思路，将向量axis绕y轴与x轴旋转变换至与z轴对齐，其角度取$arctan(y&#x2F;\sqrt{(x^2 * z^2)})$与$arctan(x&#x2F;\sqrt{(y^2 * z^2)})$，然后进行绕z轴的旋转变换再把之前进行的变换进行反变换就行了。然而稍微想想就能发现这样的错误，在绕y轴旋转之后，x与z都会发生变化，第二次旋转变换的角度完全是错误的，所以无法正确得到答案。因此，需要使用**罗德里格斯公式(Rodrigues’ rotation formula)**来解决这个问题。</p><h2 id="什么是罗德里格斯公式"><a href="#什么是罗德里格斯公式" class="headerlink" title="什么是罗德里格斯公式"></a>什么是罗德里格斯公式</h2><p>在三维旋转理论体系中，罗德里格旋转公式是在给定转轴和旋转角度后，旋转一个向量的有效算法。这个公式以欧林·罗德里格命名。罗德里格于1840年发表此公式。<br>$$ \mathbf {v} _{\mathrm {rot} }&#x3D;\mathbf {v} \cos \theta +(\mathbf {k} \times \mathbf {v} )\sin \theta +\mathbf {k} (\mathbf {k} \cdot \mathbf {v} )(1-\cos \theta )<br>$$<br>上面的公式则是罗德里格斯公式的向量形式。在图形学中，通常还会采用罗德里格斯公式的变换矩阵形式：<br>$$<br>\mathbf{R}(n,\alpha) &#x3D; cos(\alpha)\mathbf{I} + (1-cos(\alpha))\mathbf{n}\mathbf{n}^T + sin(\alpha)<br>\begin{bmatrix}<br>0&amp;-n_z&amp;n_y\<br>n_z&amp;0&amp;-n_x\<br>-n_y&amp;n_x&amp;0<br>\end{bmatrix}<br>$$<br>下面将对公式进行推导。</p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p><img src="/image/rod_image_1.png" alt="Rodrigues 旋转公式图解"><br><em>图：Rodrigues 旋转公式图解，作者 Maschen，来源 <a href="https://commons.wikimedia.org/wiki/File:Orthogonal_decomposition_unit_vector_rodrigues_rotation_formula.svg">Wikimedia Commons</a>，授权协议：CC0（公有领域）。</em><br>设将要被旋转的向量为$\mathbf{v}$, 所绕的轴单位向量为$\mathbf{k}$, $\mathbf{v}$在$\mathbf{k}$方向上竖直分量记为$\mathbf{v_{||}}$,在与$\mathbf{k}$垂直的方向上的水平分量记为$\mathbf{v_{⊥}}$, 旋转的角度为$\theta$。<br>显然：<br>$$\mathbf{v} &#x3D; \mathbf{v_{||}} + \mathbf{v_{⊥}}$$<br>当v旋转成$\mathbf{\hat{v}}$后，有<br>$$\mathbf{\hat{v}} &#x3D; \mathbf{\hat{v_{||}}} + \mathbf{\hat{v_{⊥}}}$$<br>$\mathbf{v_{||}}$与$\mathbf{k}$平行，所以$\mathbf{\hat{v_{||}}}$在旋转后依然与$\mathbf{k}$平行, 即$\mathbf{\hat{v}}$的竖直分量方向与$\mathbf{k}$一致, 有<br>$$\mathbf{\hat{v_{||}}} &#x3D; \mathbf{v_{||}} &#x3D; (\mathbf{v}·\mathbf{k})\mathbf{k}  $$<br>$\mathbf{k}×\mathbf{v} &#x3D; \mathbf{k}×(\mathbf{v_⊥} + \mathbf{v_{||}})$, 其中$\mathbf{k} × \mathbf{v_{||}} &#x3D; 0$,因此$\mathbf{k} × \mathbf{v}&#x3D; \mathbf{k} × \mathbf{v_{⊥}}$。<br>考虑水平方向的旋转，可知<br>$$\mathbf{v_{⊥}}cos\theta + (\mathbf{k}×\mathbf{v})sin\theta &#x3D; \mathbf{\hat{v_{⊥}}}$$<br>于是<br>$$\mathbf{\hat{v}} &#x3D; \mathbf{v_{⊥}}cos\theta + (\mathbf{k}×\mathbf{v})sin\theta + (\mathbf{v}·\mathbf{k})\mathbf{k}$$<br>又因为<br>$$\mathbf{v_{⊥}} &#x3D; \mathbf{v} - \mathbf{v_{||}} &#x3D; \mathbf{v} - (\mathbf{v}·\mathbf{k})\mathbf{k}  $$<br>所以<br>$$\mathbf{\hat{v}} &#x3D; (\mathbf{v} - (\mathbf{v}·\mathbf{k})\mathbf{k})cos\theta + (\mathbf{k}×\mathbf{v})sin\theta + (\mathbf{v}·\mathbf{k})\mathbf{k}$$<br>整理后得到<br>$$ \mathbf {v} &#x3D; \mathbf {v} \cos \theta +(\mathbf {k} \times \mathbf {v} )\sin \theta +\mathbf {k} (\mathbf {k} \cdot \mathbf {v} )(1-\cos \theta )<br>$$<br>也就是罗德里格斯公式的向量形式。<br>对于变换矩阵形式，我们先把$\mathbf {v}$提出来<br>$$\cos \theta +(\mathbf {k} ×\mathbf{v})&#x2F;\mathbf{v}\sin \theta +\mathbf {k} (\mathbf {k} )(1-\cos \theta )$$<br>对于向量叉乘,可以看作一个向量的反对称矩阵乘另一个向量，于是有<br>$$\mathbf {k} ×\mathbf{v} &#x3D; \begin{bmatrix}<br>    0&amp;-n_z&amp;n_y\<br>    n_z&amp;0&amp;-n_x\<br>    -n_y&amp;n_x&amp;0<br>\end{bmatrix}\mathbf{v}$$<br>令轴向量为$\mathbf {n}$,则有<br>$$\mathbf{I}\cos \theta + \begin{bmatrix}<br>    0&amp;-n_z&amp;n_y\<br>    n_z&amp;0&amp;-n_x\<br>    -n_y&amp;n_x&amp;0<br>\end{bmatrix} \sin \theta +\mathbf {n} \mathbf {n^T} (1-\cos \theta )$$<br>正是罗德里罗斯公式德变换矩阵形式。<br>体现在代码中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用Eigen线性代数库</span><br><span class="hljs-function">Eigen::Matrix4f <span class="hljs-title">get_rotation</span><span class="hljs-params">(Vector3f axis, <span class="hljs-type">float</span> angle)</span></span>&#123;<br>    <span class="hljs-comment">//Rodrigues&#x27;s Rotation Formula</span><br>    Eigen::Matrix4f r1, r2, r3;<br>    <span class="hljs-comment">//Normalize vector</span><br>    <span class="hljs-type">float</span> lenth = <span class="hljs-built_in">sqrt</span>(axis[<span class="hljs-number">0</span>] * axis[<span class="hljs-number">0</span>] + axis[<span class="hljs-number">1</span>] * axis[<span class="hljs-number">1</span>] + axis[<span class="hljs-number">2</span>] * axis[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">if</span>(lenth == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> Eigen::Matrix4f::<span class="hljs-built_in">Identity</span>();<br>    axis[<span class="hljs-number">0</span>] = axis[<span class="hljs-number">0</span>] / lenth;<br>    axis[<span class="hljs-number">1</span>] = axis[<span class="hljs-number">1</span>] / lenth;<br>    axis[<span class="hljs-number">2</span>] = axis[<span class="hljs-number">2</span>] / lenth;<br>    <span class="hljs-comment">//Horizontal component</span><br>    r1 &lt;&lt; <span class="hljs-built_in">cos</span>(angle), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-built_in">cos</span>(angle), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">cos</span>(angle), <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>;<br>    <span class="hljs-type">float</span> t = <span class="hljs-number">1</span> - <span class="hljs-built_in">cos</span>(angle);<br>    <span class="hljs-comment">//vertical component</span><br>    r2 &lt;&lt; t * axis[<span class="hljs-number">0</span>] * axis[<span class="hljs-number">0</span>], t * axis[<span class="hljs-number">0</span>] * axis[<span class="hljs-number">1</span>], t * axis[<span class="hljs-number">0</span>] * axis[<span class="hljs-number">2</span>], <span class="hljs-number">0</span>,<br>        t * axis[<span class="hljs-number">1</span>] * axis[<span class="hljs-number">0</span>], t * axis[<span class="hljs-number">1</span>] * axis[<span class="hljs-number">1</span>], t * axis[<span class="hljs-number">1</span>] * axis[<span class="hljs-number">2</span>], <span class="hljs-number">0</span>,<br>        t * axis[<span class="hljs-number">2</span>] * axis[<span class="hljs-number">0</span>], t * axis[<span class="hljs-number">2</span>] * axis[<span class="hljs-number">1</span>], t * axis[<span class="hljs-number">2</span>] * axis[<span class="hljs-number">2</span>], <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>;<br>    t = <span class="hljs-built_in">sin</span>(angle);<br>    r3 &lt;&lt; <span class="hljs-number">0</span>, t * -axis[<span class="hljs-number">2</span>], t * axis[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<br>        t * axis[<span class="hljs-number">2</span>], <span class="hljs-number">0</span>, t * -axis[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <br>        t * -axis[<span class="hljs-number">1</span>], t * axis[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>;    <br>    <span class="hljs-keyword">return</span> r1 + r2 + r3;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一题 2025.4.2</title>
    <link href="/2025/03/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%202025.4.2/"/>
    <url>/2025/03/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%202025.4.2/</url>
    
    <content type="html"><![CDATA[<p>总感觉在哪里做过, 但就是做不出来。鏖战了2小时才写出来。</p><span id="more"></span><h2 id="1278-分割回文串-III"><a href="#1278-分割回文串-III" class="headerlink" title="1278. 分割回文串 III"></a>1278. 分割回文串 III</h2><p>给你一个由小写字母组成的字符串 <code>s</code>，和一个整数 <code>k</code>。</p><p>请你按下面的要求分割字符串：</p><ul><li>首先，你可以将 <code>s</code> 中的部分字符修改为其他的小写英文字母。</li><li>接着，你需要把 <code>s</code> 分割成 <code>k</code> 个非空且不相交的子串，并且每个子串都是回文串。</li></ul><p>请返回以这种方式分割字符串所需修改的最少字符数。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong> s &#x3D; “abc”, k &#x3D; 2<br><strong>输出：</strong> 1<br><strong>解释：</strong> 你可以把字符串分割成 “ab” 和 “c”，并修改 “ab” 中的 1 个字符，将它变成回文串。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong> s &#x3D; “aabbc”, k &#x3D; 3<br><strong>输出：</strong> 0<br><strong>解释：</strong> 你可以把字符串分割成 “aa”、”bb” 和 “c”，它们都是回文串。</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong> s &#x3D; “leetcode”, k &#x3D; 8<br><strong>输出：</strong> 0</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= s.length &lt;= 100</code></li><li><code>s</code> 中只含有小写英文字母。</li></ul><p><a href="https://leetcode.cn/problems/palindrome-partitioning-iii/solutions/">https://leetcode.cn/problems/palindrome-partitioning-iii/solutions/</a></p><p>回文数的动态规划应该算是比较经典的情况了。想出状态转移方程也应该不会太难。</p><p>很显然, 有字符串长度和分割字串数目这两个参数。然后再寻找两个参数和状态之间的关系。</p><p>可以发现, <strong>如果将长度为i字符串分割j块, 其实也就相当于前i-l个字符组成的字符串分割成j-1块, 再加上后l个字符组成的字符串组合</strong>。已经分割好的字符串需要改变的字母数量是很好得出的(虽然我在这里因为少加了个前边界卡了1个小时)。<br><strong>于是, 只要把前i-l个字符组成的字符串分割j-1块后需要修改的字母数加上后l个字符组成的字符串组合需要修改的字母数加上, 就是总共需要修改的字母数。</strong></p><p>再选取所有分割方式中需要修改字母数最少的情况,于是得到状态转移方程:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = min(dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>, dp<span class="hljs-comment">[i - l]</span><span class="hljs-comment">[j - 1]</span> + f(i-l,i));<br></code></pre></td></tr></table></figure><p>为方便传递参数, 后面的程序中写成了</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = min(dp<span class="hljs-comment">[m]</span><span class="hljs-comment">[j - 1]</span> + f(s, m, i - 1), dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>);<br></code></pre></td></tr></table></figure><p>其中, f(i-l,i)是字符串i - l到i需要修改的字符数量。这个只需要统计前半的字符串与后半的字符串倒序有几个字符不同就好了。</p><p>最后就是边界条件。当j &#x3D; 1时, 显然dp[i][1]就等于f(0,i), i - l &gt;&#x3D; j - 1。<br>题解:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>        <span class="hljs-type">int</span> i, n = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i = a; i &lt;= (a + b)/<span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] != s[b - i + a])n++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">palindromePartition</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), i, j, m;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(k + <span class="hljs-number">1</span>, INT_MAX));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-built_in">min</span>(i, k); j++)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">1</span>)&#123;<br>                    dp[i][j] = <span class="hljs-built_in">f</span>(s, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">for</span>(m = j - <span class="hljs-number">1</span>; m &lt; i; m++)&#123;<br>                        dp[i][j] = <span class="hljs-built_in">min</span>(dp[m][j - <span class="hljs-number">1</span>] + <span class="hljs-built_in">f</span>(s, m, i - <span class="hljs-number">1</span>), dp[i][j]);<br>                    &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>leetcode</category>
      
      <category>动态规划</category>
      
      <category>困难</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c++primer第四章笔记</title>
    <link href="/2025/02/09/c++primer%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/02/09/c++primer%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>用于个人学习笔记使用,可能会存在许多错误与模糊的地方。</p><span id="more"></span><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>C++的表达式分为左值和右值, 左值可以位于赋值语句左侧, 右值不能。在需要右值的地方可以用左值来代替, 但是不能把右值当成左值来使用。在等号右边的值也可以是左值。可以简单理解为左值是可以被访问到地址的值。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//部分左值</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">int</span>*p = &amp;a;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-comment">//部分右值</span><br><span class="hljs-number">10</span>;<br>a + b;<br>fmin(a, b);传参返回的值。<br></code></pre></td></tr></table></figure><p>右值一般都是临时的值。</p><h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>左值引用即是对左值的引用, 即给左值取别名。这样的好处在于不用为形参再分配内存空间, 在深度套用函数和大量参数的情况下可以提高函数的时间和空间效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aa</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; rb)</span><span class="hljs-comment">//此时用右值会报错</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aaa</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rb)</span><span class="hljs-comment">//在添加const以后可以兼容右值, 同时添加const既可以保证实参不会被修改</span></span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; ra </span>= a;<br><span class="hljs-type">int</span>*&amp; rp = p;<br><span class="hljs-type">int</span>&amp; r = *p;<br><span class="hljs-built_in">aa</span>(ra);<br></code></pre></td></tr></table></figure><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>右值引用即使对右值的引用, 即给右值取别名。某种意义上可以临时的右值的使用周期。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aaa</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; a)</span><span class="hljs-comment">//如果同时与上面的aaa一起写将会实现函数重载, 编译器会在实参是左值时采用上面的函数, 右值时采用下面的函数。</span></span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp;&amp; rr1 </span>= <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span>&amp;&amp; rr2 = a + b;<br></code></pre></td></tr></table></figure><h3 id="decltype与引用"><a href="#decltype与引用" class="headerlink" title="decltype与引用"></a>decltype与引用</h3><p>使用decltype时, 表达式求值结果为左值, decltype得到一个引用类型。p为int<em>类型, 解运算符生成左值, decltype会生成int&amp;。<br>而取地址运算符生成右值, decltype(&amp;p)结果是int</em>*, 是一个指向整型指针的指针。</p><h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>对于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">int i = f1() * f2();<br>cout &lt;&lt; <span class="hljs-string">i &lt;&lt; &quot; &quot; &lt;&lt; ++i</span> &lt;&lt; <span class="hljs-string">endl;</span><br></code></pre></td></tr></table></figure><p>f1()与f2()一定会在*之前运算, 但无法知道f1()与f2()的调用顺序。如果f1()和f2()会影响同一对象, 那它作为一条错误的表达式, 将产生未定义的行为。<br>&lt;&lt;运算符没有规定何时以及如何对运算对象求值, 因此第二条输出表达式时未定义的。编译器可能会先求++i的值再求i的值, 也可能反过来。<br>逻辑与(&amp;&amp;), 逻辑或(||), 条件或(:?), 逗号(,)这些是明确规定了运算对象求值顺序的运算符, 只有在运算了左边的运算对象之后才会求右侧运算对象的值。<br>运算对象的求值顺序与优先级和结合律无关。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><h2 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h2><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>大多数运算符没有规定运算对象的求值顺序。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">while(<span class="hljs-keyword">beg </span>!= s<span class="hljs-meta">.end</span>() &amp;&amp; !isspace(*<span class="hljs-keyword">beg))&#123;</span><br><span class="hljs-keyword"></span>    *<span class="hljs-keyword">beg </span>= toupper(*<span class="hljs-keyword">beg++);</span><br><span class="hljs-keyword"></span>&#125;<br></code></pre></td></tr></table></figure><p>这段将会产生未定义行为。问题在于, 赋值运算符左右两次用到了beg, 且右边的运算对象改变了beg的值, 该赋值语句未定义。编译器可能先求左边的值, 也可能先求右边的beg + 1, 也可能采取别的方式。</p><h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>成员访问运算符分为点运算符和箭头运算符。其中点运算符通过实例直接访问成员, 箭头运算符则要先对指针解引用, 再访问成员.</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ptr-&gt;mem<span class="hljs-comment">;</span><br>(*ptr).mem<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>两者等价。<br>解引用运算符的优先级低于点运算符, 因此执行解引用运算的子表达式两端必须要加上括号, 如果没加上括号代码含义将会不相同。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">*p.size();<span class="hljs-regexp">//</span>错误, p是一个指针, 没有名为size的成员。<br></code></pre></td></tr></table></figure><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><img src="/image/bitys1.png" alt="图片" title="位运算符"><br>位运算符的重载版本常用于IO操作, 重载运算符的优先级和结合律和内置版本一样。移位运算符满足左结合律, 因此表达式</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf">cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; <span class="hljs-string">&quot;world&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br><span class="hljs-comment">//等同于</span><br>((cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;world&quot;</span>) &lt;&lt; <span class="hljs-literal">endl</span>;<br></code></pre></td></tr></table></figure><p>移位运算符的优先级不高不低, 所以有时候要加上括号来保证结果符合预期。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cout</span> &lt;&lt; (<span class="hljs-number">10</span> &lt; <span class="hljs-number">42</span>);//正确<br><span class="hljs-attribute">cout</span> &lt;&lt; <span class="hljs-number">10</span> &lt; <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure><p>由于&lt;&lt;优先级大于&lt;, 因此该语句会变成把10写到cout, 将结果与42比较。</p><h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><p>sizeof运算符会返回一条表达式或者一个类型名所占的字节数。sizeof运算符满足右结合律, 所得值为size_t类型。运算对象有两种形式。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-built_in">sizeof</span> (<span class="hljs-keyword">type</span>);<span class="hljs-comment">//返回类型所占字节数</span><br><span class="hljs-built_in">sizeof</span> expr;<span class="hljs-comment">//返回表达式结果类型的大小。sizeof并不实际计算其运算对象的值。</span><br></code></pre></td></tr></table></figure><p>在C++11允许使用sizeof可以不用通过具体的对象而是通过作用域运算符来获取类成员的大小。<br>·对char或者类型为char的表达式执行sizeof运算结果为1。<br>·对引用类型执行sizeof运算结果为被引用对象所占空间的大小。<br>·对指针执行sizeof运算得到指针本身所占空间的大小。<br>·对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小, 指·针不需要有效。<br>·对数组执行sizeof运算得到整个数组所占空间的大小, 等价于对数组中的所有元素各执行一次sizeof运算并将所得结果求和。(不会转换成指针处理)<br>·对string对象或vector对象执行sizeof运算只会返回该类型固定部分的大小, 不会计算对象中元素占用了多少空间。<br>可以通过sizeof来得到数组中的元素个数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">auto sz = <span class="hljs-keyword">sizeof</span>(ia)/<span class="hljs-keyword">sizeof</span>(*ia);<br><span class="hljs-built_in">int</span> arr2[sz]; <span class="hljs-comment">//sizeof 返回常量表达式, 可以用于声明数组维度。</span><br></code></pre></td></tr></table></figure><h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在C++中, 如果两种类型可以相互转换, 那么它们就是关联的。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> ival = <span class="hljs-number">3</span>.<span class="hljs-number">14</span> + <span class="hljs-number">3</span>;//编译器可能会警告丢失精度<br></code></pre></td></tr></table></figure><p>C++不会将两个不同类型的值相加, 会根据类型转换规则统一后再求值。这个过程是自动的, 因此被称为隐式转换。<br>隐式转换被设计得会尽量避免丢失精度, 再上述运算中, 3会被转换成double类型再执行浮点数加法, 得到double类型。然后再完成初始化任务, 此时加法运算的double类型将会转换成int类型, 再用这个值来初始化ival。</p><h3 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h3><h3 id="其他隐式转换"><a href="#其他隐式转换" class="headerlink" title="其他隐式转换"></a>其他隐式转换</h3><p>数组转换成指针: 在大多数用到数组的表达式, 数组会自动转换成数组首元素的指针。当数组被用作decltype关键字的参数, 或者作为取地址符sizeof等运算符的运算对象时, 上述转换不会发生。<br>指针的转换: 0或nullptr能转换成任意指针类型。指向任意非常量的指针能转换成void*; 指向任意对象的指针能转换成const void*。<br>转换成布尔类型: 可以从算术类型或指针类型转换成布尔类型。若值为0, 结果为false, 否则为true。<br>转换成常量: 允许将指向非常量类型的指针转换成指向响应常量类型的指针。相反则不存在。<br>类类型定义的转换</p><h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>命名的强制转换类型:一个命名的强制转换类型有以下形式:<br><em>cast-name<type>(expression);</em><br>type是转换的目标类型, expression是要转换的值。cast-name指定了执行的是哪种转换。<br>static_cast只要不包含底层const都能用。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> slope = static_cast&lt;<span class="hljs-built_in">double</span>&gt;(j)/i;<br><span class="hljs-built_in">void</span>* p = &amp;d;<br><span class="hljs-built_in">double</span> *dp = static_cast&lt;<span class="hljs-built_in">double</span>*&gt;(p);<span class="hljs-comment">//找回void*的指针</span><br></code></pre></td></tr></table></figure><p>const_cast只能改变运算对象的底层const, 且只有const_cast可以改变。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *pc;<br><span class="hljs-type">char</span> *p = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(pc);<br></code></pre></td></tr></table></figure><p>reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。<br>旧式的强制类型转换:<br><em>type(expr);</em><br><em>(type) expr;</em><br>如果换成static_cast合法,则与static_cast用法一致。<br>否则与reinterpret_cast一致。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">char</span> *pc = (<span class="hljs-type">char</span>*) ip;<span class="hljs-comment">//ip为指向整数的指针。与reinterpret_cast一致。</span><br></code></pre></td></tr></table></figure><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p>goto语句可以无条件跳转到同一函数的另一条语句。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">goto</span> lable;<br>end: <span class="hljs-keyword">return</span>;<span class="hljs-comment">//lable语句</span><br></code></pre></td></tr></table></figure><h2 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h2><p>异常检测部分使用throw表达式来表达它遇到了无法处理的问题, throw引发了异常。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">cerr &lt;&lt; <span class="hljs-string">&quot;Data must refer to same ISBN&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//输出错误信息表示失败</span><br><span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">&quot;Data must refer tp &quot;</span>);<span class="hljs-comment">//会直接扔出一个异常</span><br></code></pre></td></tr></table></figure><p>类型runtime_error是一种标准库异常类型。</p><h2 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h2><p>try语句块的一开始是关键字try, 随后紧跟着一个块, 这个块一般是用花括号括起来的语句序列。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title function_">try</span>&#123;<br>    <span class="hljs-variable">program</span><span class="hljs-operator">-</span><span class="hljs-variable">statements</span><br>&#125;<span class="hljs-title function_">catch</span>(<span class="hljs-params">exception</span>-<span class="hljs-params">declaration</span>)&#123;<br>    <span class="hljs-variable">handler</span><span class="hljs-operator">-</span><span class="hljs-variable">statements</span><br>&#125;<span class="hljs-title function_">catch</span>(<span class="hljs-params">exception</span>-<span class="hljs-params">declaration</span>)&#123;<br>    <span class="hljs-variable">handler</span><span class="hljs-operator">-</span><span class="hljs-variable">statements</span><br>&#125;<br></code></pre></td></tr></table></figure><p>跟在try块后面的是一个或者多个catch字句。catch字句包括关键字catch、括号内的异常声明以及一个块。当选中catch字句处理异常后, 执行与之对应的块。<br>例如</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">while</span>(cin &gt;&gt; item1 &gt;&gt; item2)&#123;<br>    try&#123;<br>        <span class="hljs-comment">//尝试添加两个sales_item对象, 添加失败会抛出runtime_error异常</span><br>    &#125;<span class="hljs-built_in">catch</span>(runtime_error)&#123;<br>        <span class="hljs-comment">//提示用户错误</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h2><p>C++标准库定义了一组类, 用于报告标准库函数中遇到的问题。这些异常类也可以用在用户编写的程序中使用, 它们分别定义在4个头文件中。<br>exception头文件定义了最通用的异常类exception。它只报告异常的发生, 不提供额外信息。<br>stdexcept提供了以下的常用异常类。<br><img src="/image/stderror1.png" alt="图片" title="stdexcept提供的常用类"><br>new头文件定义了bad_alloc异常类型。<br>type_info头文件定义了bad_cast异常类型。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>典型的函数定义包含以下部分: 返回类型、函数名、由0个或多个形参组成的列表以及函数体。形参由逗号隔开, 形参的列表位于圆括号内。</p><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p>实参是形参的初始值, 实参和形参的初始化顺序是对应的, 但没有规定实参的求值顺序, 编译器可以以任意可行的顺序对实参求值。<br>实参与形参的类型也应当是匹配的。函数的调用规定实参数与形参数量一致, 所以形参一定会被初始化。</p><p>函数的形参列表可以为空, 但是不可以省略。为了与C语言兼容, 也可以用关键字void表示函数没有形参。形参列表的形参用逗号隔开。<br>void类型的函数不返回任何值。</p><h2 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h2><p>在C++中, 名字有作用域, 对象有生命周期。形参和函数体内部定义的变量统称为局部变量, 它们仅在函数的作用域内可见。<br>普通局部变量对应的对象, 当函数的控制路径经过变量定义语句时创建该对象, 到达定义所在块的末尾时销毁它。这种仅存在于块执行期间的对象为自动对象。<br>当块的实行结束后, 块中创建的自动对象就变成未定义的了。形参就是一种自动对象, 函数开始时为形参申请存储空间, 函数一旦终止, 形参就销毁了。<br>可以将局部变量定义成static类型获得局部静态对象。局部静态对象在程序执行路径第一次经过对象定义时初始化, 直到程序终止时才销毁, 在此期间对象所在的函数结束执行也不会有任何影响。</p><p>练习6.7</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">num</span>()</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> n++;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>函数的名字在使用前需要声明, 函数只能定义一次, 但是可以声明多次。如果一个函数永远不会被用到, 那么它也可以只有声明没有定义。函数的声明和函数的定义非常类似, 区别在函数声明不需要函数体, 用一个分号替代就可以。<br>最好在头文件中进行函数声明, 在源文件中定义。</p><h2 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h2><p>分离式编译允许C++把程序分割到几个文件中, 每个文件独立编译。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//add.h,add.cpp,main.cpp</span><br>g++ -c add<span class="hljs-selector-class">.cpp</span> -o add.o<span class="hljs-comment">//编译add.cpp,-c只编译,不连接。-o指定输出文件main.cpp。windows下为.obj</span><br>g++ -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> -o <span class="hljs-selector-tag">main</span>.o<span class="hljs-comment">//编译main.cpp</span><br>g++ add<span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> -o main<span class="hljs-comment">//连接add和main -o指定最终输出可执行文件main</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c++primer第三章笔记</title>
    <link href="/2025/01/20/c++primer%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/20/c++primer%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>用于个人学习笔记使用,可能会存在许多错误与模糊的地方。</p><span id="more"></span><h1 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>::name;<br></code></pre></td></tr></table></figure><p>使用using声明之后就可以直接访问命名空间中的名字。例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cin;<span class="hljs-comment">//编译器应当从左侧名字所示的作用域中寻找右边的名字</span><br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    cin &gt;&gt; i;<br>    std::cout &lt;&lt; i &lt;&lt; endl;<span class="hljs-comment">//std还没有声明，需要使用完整的访问</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个名字都需要单独的声名。头文件不应当包含using声明。</p><h1 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h1><p>string作为标准库的一部分,定义在命名空间std中。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#include &lt;string&gt;</span><br>using std::string;<br>string <span class="hljs-built_in">s1</span>, <span class="hljs-built_in">s2</span>(<span class="hljs-built_in">s1</span>), <span class="hljs-built_in">s3</span> = <span class="hljs-built_in">s1</span>, <span class="hljs-built_in">s4</span>(<span class="hljs-string">&quot;value&quot;</span>), <span class="hljs-built_in">s5</span> = <span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-built_in">s6</span>(n, <span class="hljs-string">&#x27;c&#x27;</span>);<br></code></pre></td></tr></table></figure><p>使用等号是拷贝初始化，不使用等号是直接初始化。</p><h2 id="string对象的操作"><a href="#string对象的操作" class="headerlink" title="string对象的操作"></a>string对象的操作</h2><p><img src="/image/string1.png" alt="图片" title="string对象的操作"></p><p>string的size函数返回的是一个string::size_type类型的值。其是一个无符号类型的值且足够存放下任何string对象的大小。因为string::size_type返回的是一个无符号类型的值,所以用其与有符号类型的值比较的时候要注意转换,比如s.size() &lt; n,当n为小于0的int类型时,结果会为true,因为n会转换成一个较大的无符号类型数。</p><p>string在比较中遵循:1.长度不同，若较短的string对象每个字符与更长的对象上对应位置上的字符位置相同则较短对象小于较长对象。2.如果对象在对应位置上的字符不一致,则string对象比较的结果为第一个不同字符比较的结果。3.大小写敏感。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">string a<span class="hljs-comment">;</span><br>unsigned b <span class="hljs-operator">=</span> sizeof(a)<span class="hljs-comment">;//b(string对象的大小)恒定为32, 在不同编译器中也可能是40</span><br></code></pre></td></tr></table></figure><p><img src="/image/cctype1.png" alt="图片" title="cctype头文件中的函数"></p><h1 id="基于范围的for语句"><a href="#基于范围的for语句" class="headerlink" title="基于范围的for语句"></a>基于范围的for语句</h1><p>C++11新标准提供范围for语句:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">for</span>(declaration:expression)<br><span class="hljs-regexp">//</span>expression:对象,表示一个序列 <br><span class="hljs-regexp">//</span>declaration:负责定义一个变量用于访问序列中的基础元素,<br><span class="hljs-regexp">//</span>会初始化为expression部分的下一个元素值。<br>    statement<br></code></pre></td></tr></table></figure><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;some string&quot;</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : s)<br>    cout &lt;&lt; i &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>使用范围for语句改变字符串中的字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;some string&quot;</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;i : s)<span class="hljs-comment">//i为引用</span><br>    i = <span class="hljs-built_in">toupper</span>(i);<span class="hljs-comment">//i为引用,相当于是元素的别名,因此相当于修改了原本的元素。</span><br></code></pre></td></tr></table></figure><p>下标索引符[]</p><h1 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h1><p>标准库类型vector表示对象的集合,其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引,索引用于访问对象。vector也被称为容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> std::vector;<br>vector&lt;<span class="hljs-type">int</span>&gt; ivec = <span class="hljs-number">1</span>;           <span class="hljs-comment">//vector保存int类型对象</span><br>vector&lt;Sales_item&gt; Sales_vec;   <span class="hljs-comment">//vector保存Sales_item类型对象</span><br>vector&lt;vector&lt;string&gt;&gt; file;    <span class="hljs-comment">//vector保存vector对象</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec1</span><span class="hljs-params">(ivec)</span></span>;        <span class="hljs-comment">//初始化为ivec所有元素的副本</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec0</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>)</span></span>;       <span class="hljs-comment">//初始化10个为1的对象(默认为0)</span><br>vector&lt;string&gt; svec&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;the&quot;</span>&#125;;<span class="hljs-comment">//列表初始化为3个元素</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec2</span><span class="hljs-params">(<span class="hljs-number">10</span>, ivec)</span></span>;    <span class="hljs-comment">//创建指定数量的元素</span><br><span class="hljs-comment">//向vector对象中添加元素,直到运行时知道元素的数量</span><br><span class="hljs-comment">//不能直接用下标索引符[]添加元素,只能对确知已执行的元素执行下标操作</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>ivec.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>vector其它操作<br><img src="/image/vector1.png" alt="图片" title="vector的其它操作"><br>其方法与访问string对象中字符的方法差不多。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//练习3.17</span><br><span class="hljs-built_in">int</span> main()&#123;<br>    vector&lt;<span class="hljs-built_in">string</span>&gt; s;<br>    <span class="hljs-built_in">string</span> <span class="hljs-keyword">is</span>;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; <span class="hljs-keyword">is</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">auto</span> &amp;i : <span class="hljs-keyword">is</span>)<br>            i = toupper(i);<br>        s.push_back(<span class="hljs-keyword">is</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">auto</span> i : s)<br>        cout &lt;&lt; i &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//练习3.20</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vint;<br>    <span class="hljs-type">int</span> i, n;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; i)vint.<span class="hljs-built_in">push_back</span>(i);<br>    n = vint.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">//没有相邻的元素存在</span><br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error data!&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//上半问</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;t1:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i)<br>        cout &lt;&lt; vint[i] + vint[i + <span class="hljs-number">1</span>] &lt;&lt; endl;<br>    <span class="hljs-comment">//下半问</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;t2:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        cout &lt;&lt; vint[i] + vint[n - <span class="hljs-number">1</span> -i] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>string与vector都支持迭代器。<br>begin与end成员</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">auto b = v.begin(); <span class="hljs-regexp">//</span>返回指向第一个元素的迭代器<br>auto e = v.end();   <span class="hljs-regexp">//</span>返回尾元素的下一个位置的迭代器<br><span class="hljs-regexp">//</span>容器为空时,begin与end返回同一个迭代器   <br></code></pre></td></tr></table></figure><p>当对象时常量时,begin和end返回const_iterator,否则返回iterator。如果只需要读操作,可以用cbegin和cend两个函数来强行返回const_iterator。<br><img src="/image/ddq1.png" alt="图片" title="迭代器的运算符"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//迭代器实现二分</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vint;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> sought;<br>    cin &gt;&gt; sought;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; a)vint.<span class="hljs-built_in">push_back</span>(a);<br>    <span class="hljs-keyword">auto</span> beg = vint.<span class="hljs-built_in">begin</span>(), end = vint.<span class="hljs-built_in">end</span>();<br>    <span class="hljs-keyword">auto</span> b = beg;<br>    <span class="hljs-keyword">auto</span> mid = vint.<span class="hljs-built_in">begin</span>() + (end - beg)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(mid &lt; end &amp;&amp; *mid != sought)&#123;<br>        <span class="hljs-keyword">if</span>(sought &lt; *mid)           <span class="hljs-comment">//判断是否在前半部分</span><br>            end = mid;              <br>        <span class="hljs-keyword">else</span>                        <span class="hljs-comment">//在后半部分</span><br>            beg = mid + <span class="hljs-number">1</span>;<br>        mid = beg + (end - beg)/<span class="hljs-number">2</span>;<br>    &#125;<br>    cout &lt;&lt; mid - b;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h2><p>a[d],其中a是数组的名字,d是数组的维度。数组的维度应当大于0,且在编译的时候应该是已知的。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];  <span class="hljs-comment">//10个整数的数组</span><br><span class="hljs-keyword">int</span> *pa[<span class="hljs-number">10</span>];<span class="hljs-comment">//10个整型指针的数组</span><br><span class="hljs-keyword">char</span> b0[] = &#123;<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>&#125;;<br><span class="hljs-keyword">char</span> b1[] = &#123;<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><span class="hljs-keyword">char</span> b2[] = <span class="hljs-string">&#x27;c++&#x27;</span>;<span class="hljs-comment">//字符串最后会有一个空字符</span><br><span class="hljs-keyword">char</span> b3[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;c++&#x27;</span>;<span class="hljs-comment">//错误,没有放最后一个空字符的空间</span><br><br><span class="hljs-keyword">int</span> *ptrs[<span class="hljs-number">10</span>];<span class="hljs-comment">//含有10个整形指针的数组</span><br><span class="hljs-keyword">int</span> (*parray)[<span class="hljs-number">10</span>] = &amp;arr;<span class="hljs-comment">//指向一个含有10个整数的数组</span><br><span class="hljs-keyword">int</span> (&amp;arrref)[<span class="hljs-number">10</span>] = arr;<span class="hljs-comment">//引用一个含有10个整数的数组</span><br><span class="hljs-keyword">int</span> *(&amp;arry)[<span class="hljs-number">10</span>] = ptrs;<span class="hljs-comment">//arry引用,该数组有10个指针</span><br><span class="hljs-comment">//数组声明的含义从数组的名字由内向外的顺序阅读</span><br></code></pre></td></tr></table></figure><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>数组也可以使用范围for语句或下标运算符来访问。在使用数组下标的时候,通常将其定义为size_t类型。<br>在使用数组时应当要检查下标是否在合理范围之内。</p><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><p>使用数组时,编译器一般会把它转换成指针。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> nums[] = &#123;<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>&#125;;<br><span class="hljs-built_in">string</span> *p = &amp;nums[<span class="hljs-number">0</span>];<br><span class="hljs-built_in">string</span> *p2 = nums;<span class="hljs-comment">//数组名编译器会将其替换为首元素的指针,等价于p2 = &amp;nums[0]</span><br></code></pre></td></tr></table></figure><p>一些情况下数组的操作实际上是指针的操作。<br>比如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-attribute">auto</span> ia2(ia);<br></code></pre></td></tr></table></figure><p>初始化会类似于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(&amp;ia[<span class="hljs-number">0</span>])</span></span>;<br>++ia2; <span class="hljs-comment">//指向ia[1];</span><br><span class="hljs-type">int</span> *e = &amp;ia[<span class="hljs-number">10</span>];<span class="hljs-comment">//获取尾后指针</span><br></code></pre></td></tr></table></figure><h3 id="指针也是迭代器"><a href="#指针也是迭代器" class="headerlink" title="指针也是迭代器"></a>指针也是迭代器</h3><p>auto推断的类型为指针而非数组。此时指针也可以作为迭代器使用。也可以利用尾元素后不存在的那个元素获取尾后指针。尾后指针和迭代器一样不指向具体的元素,不能对尾后指针进行解引用或者递增的操作。</p><h3 id="begin与end函数"><a href="#begin与end函数" class="headerlink" title="begin与end函数"></a>begin与end函数</h3><p>数组中有begin和end函数,可以更简单安全地获取数组的首尾指针。</p><h3 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h3><p>给指针加上一个整数,得到的新指针依然指向同一数组的其他元素或者同一数组尾元素的下一位置(尾指针)。和迭代器相同,两个指针相减的结果是其距离,结果是一种名为ptrdiff_t的标准库类型(带符号)。<br>如果两个指针指向同一个数组的元素或尾元素的下一位置,就能运用关系运算符比较。两个指针指向的对象不相关则不能比较。</p><h3 id="指针与下标"><a href="#指针与下标" class="headerlink" title="指针与下标"></a>指针与下标</h3><p>标准库类型string与vector也能执行下标运算,不过string与vector要求下标是无符号类型,内置的下标运算无此要求。结果地址必须指向原来指针所指(或尾指针)的同一数组的元素。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">int</span> *beg = <span class="hljs-keyword">begin</span>(ia);<br><span class="hljs-keyword">int</span> *<span class="hljs-keyword">end</span> = <span class="hljs-keyword">end</span>(ia);<br><span class="hljs-keyword">while</span>(beg != <span class="hljs-keyword">end</span> &amp;&amp; beg &gt;= <span class="hljs-number">0</span>)beg++;<span class="hljs-comment">//寻找第一个负数</span><br><span class="hljs-keyword">int</span> *ip = ia2;<span class="hljs-comment">//ip指向ia[1]</span><br>ip += <span class="hljs-number">2</span>;<span class="hljs-comment">//ip指向ia[3];</span><br><span class="hljs-keyword">int</span> len = <span class="hljs-keyword">end</span>(ia) - <span class="hljs-keyword">begin</span>(ia);<span class="hljs-comment">//为数组中的元素个数。</span><br><span class="hljs-keyword">while</span>(ia2 &lt; ip)&#123;<br>    ia2++;<br>    cout &lt;&lt; *ia2;<span class="hljs-comment">//数组指针解引用</span><br>&#125;<span class="hljs-comment">//遍历ia2到ip</span><br><span class="hljs-keyword">int</span> a = *(ip - <span class="hljs-number">3</span>);<span class="hljs-comment">//a为ip[0]</span><br><span class="hljs-keyword">int</span> k = ip[-<span class="hljs-number">2</span>];<span class="hljs-comment">//ip[-2]为ia[1]</span><br></code></pre></td></tr></table></figure><h3 id="指针与数组练习"><a href="#指针与数组练习" class="headerlink" title="指针与数组练习"></a>指针与数组练习</h3><p>3.36</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs smali">int main()&#123;<br>   <span class="hljs-built_in"> int </span>n1[] = &#123;1, 2, 3&#125;;<br>   <span class="hljs-built_in"> int </span>n2[] = &#123;1, 2, 3&#125;;<br>   <span class="hljs-built_in"> int </span>*p1 = n1, *p2 = n2;<br>    auto end1 = std::end(n1);<br>    auto end2 = std::end(n2);<br>    //判断元素数目是否相同<br>    if((end1 - p1) != (end2 - p2))&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;These two arrays are different.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    //若元素数目相同再判断具体元素<br>    else&#123;<br>        while(p1 &lt; end1 &amp;&amp; p2 &lt; end2 &amp;&amp; *p1 == *p2)&#123;<br>            ++p1;<br>            ++p2;<br>        &#125;<br>        if(p1 != end1)cout &lt;&lt; <span class="hljs-string">&quot;These two arrays are different.&quot;</span> &lt;&lt; std::endl;<br>        else cout &lt;&lt; <span class="hljs-string">&quot;These two arrays are the same.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    //vector迭代器类似<br>    vector&lt;int&gt; vint1 = &#123;1, 0, 3&#125;, vint2 = &#123;1, 2, 3&#125;;<br>    auto vp1 = vint1.begin(), vp2 = vint2.begin();<br>    auto endv1 = vint1.end(), endv2 = vint2.end();<br>    if((endv1 - vp1) != (endv2 - vp2))&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;These two vectors are different.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    else&#123;<br>        while(vp1 &lt; endv1 &amp;&amp; vp2 &lt; endv2 &amp;&amp; *vp1 == *vp2)&#123;<br>            ++vp1;<br>            ++vp2;<br>        &#125;<br>        if(vp1 != endv1)cout &lt;&lt; <span class="hljs-string">&quot;These two vectors are different.&quot;</span> &lt;&lt; std::endl;<br>        else cout &lt;&lt; <span class="hljs-string">&quot;These two vectors are the same.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>   <span class="hljs-built_in"> return </span>0;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h2><p>将字符串存放在字符数组中并以空字符(‘\0’)结束。最好别用。</p><h3 id="C标准库String函数-定义于Cstring头文件中"><a href="#C标准库String函数-定义于Cstring头文件中" class="headerlink" title="C标准库String函数(定义于Cstring头文件中)"></a>C标准库String函数(定义于Cstring头文件中)</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">strlen(p); //返回p的长度<br>strcmp(p1, p2); //比较p1和p2是否相等, 相等返回0; 如果p1&gt;p2, 返回一个正值, 如果p1小于p2, 返回负值<br>strcat(p1, p2); //将p2附加到p1之后, 返回p1<br>strcpy(p1, p2); //将p2拷贝给p1, 返回p1<br></code></pre></td></tr></table></figure><p>实际上p就是char<em>类型。<br>C风格字符串比较的是const char</em>的值。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">string s1 = <span class="hljs-string">&quot;A string example&quot;</span>;<br>string s2 = <span class="hljs-string">&quot;A other string&quot;</span>;<br><span class="hljs-keyword">if</span>(s1 &lt; s2)<span class="hljs-regexp">//</span>false;<br><span class="hljs-regexp">//</span>等效于<br><span class="hljs-keyword">if</span>(strcmp(c1, c2) &lt; <span class="hljs-number">0</span>);<br><br>const char ca1[] = <span class="hljs-string">&quot;A string example&quot;</span>;<br>const char ca2[] = <span class="hljs-string">&quot;A different string&quot;</span>;<br><span class="hljs-keyword">if</span>(ca1 &lt; ca2)<span class="hljs-regexp">//</span>未定义, 比较两个无关的地址<br><br><span class="hljs-regexp">//</span>连接两个字符串<br>string largeStr = s1 + <span class="hljs-string">&quot; &quot;</span> + s2;<br><span class="hljs-regexp">//</span>ca1 + ca2相当于将两个指针相加,无意义<br>strcpy(largeStr, ca1);  <span class="hljs-regexp">//</span>cal拷贝给largeStr<br>strcat(largeStr, <span class="hljs-string">&quot; &quot;</span>);  <span class="hljs-regexp">//</span>在largeStr的末尾加一个空格<br>strcat(largeStr, ca2);  <span class="hljs-regexp">//</span>把ca2连接到largeStr后面<br><span class="hljs-regexp">//</span>需要正确估计largeStr所需要的空间, 这种代码具有风险, 容易导致严重的安全泄露<br></code></pre></td></tr></table></figure><h2 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h2><h3 id="string对象与C风格字符串"><a href="#string对象与C风格字符串" class="headerlink" title="string对象与C风格字符串"></a>string对象与C风格字符串</h3><p>任何出现字符串字面值的地方都可以用以空字符结束的字符数组替代。</p><p>反过来不成立, string无法直接替代C风格字符串, 但可以用c_str成员函数来实现string转换C风格字符串。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span> = s;<span class="hljs-comment">//错误</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span> = s.c_str();<br></code></pre></td></tr></table></figure><h3 id="使用数组初始化vector对象"><a href="#使用数组初始化vector对象" class="headerlink" title="使用数组初始化vector对象"></a>使用数组初始化vector对象</h3><p>数组可以用来初始化vector对象,但是vector对象不能用来初始化数组。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> int_arr[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-attribute">vector</span>&lt;int&gt; ivec(begin(int_arr), end(int_arr));//用数组来初始化vector对象<br><span class="hljs-attribute">vector</span>&lt;int&gt; subvec(int_arr + <span class="hljs-number">1</span>, int_arr + <span class="hljs-number">4</span>);//初始化部分对象(int_arr[<span class="hljs-number">1</span>], int_arr[<span class="hljs-number">2</span>], int_arr[<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说, C++语言中没有多维数组,通常说的多维数组实际上是数组的数组。当一个数组元素仍然是数组时, 一个维度表示数组本身大小, 另一个维度表示其元素(也是数组)的大小。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];//大小为<span class="hljs-number">3</span>的数组,每个元素是含有<span class="hljs-number">4</span>个整数的数组<br><span class="hljs-attribute">int</span> arr[<span class="hljs-number">10</span>][<span class="hljs-number">20</span>][<span class="hljs-number">30</span>] = &#123;<span class="hljs-number">0</span>&#125;;//将所有元素初始化为<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以使用花括号括起来一组值初始化多维数组。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">int ia[3][4] = </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    &#123;0, 1, 2, 3&#125;</span><span class="language-xml">,</span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;4, 5, 6, 7&#125;</span><span class="language-xml">,</span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;8, 9, 10, 11&#125;</span><span class="language-xml">,</span><br><span class="language-xml">&#125;;</span><br></code></pre></td></tr></table></figure><p>其中花括号非必须。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;;<br></code></pre></td></tr></table></figure><p>只初始化部分元素:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">8</span>&#125;&#125;;<br><span class="hljs-comment">//显示的初始化每行的首元素。</span><br><span class="hljs-built_in">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>&#125;;<span class="hljs-comment">//剩余元素执行默认初始化。</span><br></code></pre></td></tr></table></figure><h3 id="使用范围for语句处理多维数组"><a href="#使用范围for语句处理多维数组" class="headerlink" title="使用范围for语句处理多维数组"></a>使用范围for语句处理多维数组</h3><p>遍历ia</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-keyword">for</span>(auto &amp;<span class="hljs-built_in">row</span> : ia)&#123;<br>    <span class="hljs-keyword">for</span>(auto &amp;<span class="hljs-built_in">col</span> : <span class="hljs-built_in">row</span>)<br>        cout &lt;&lt; <span class="hljs-built_in">col</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>在没有写操作的时候, 最好也选用引用类型作为循环控制变量。在上面的遍历中, 如果不使用引用程序将无法通过编译。因为外层循环时, 编译器会像其它数组一样, 将row视作是指向数组首元素的指针,也就是int*类型, 因此在内层循环时将会变成遍历一个指针, 这显然是非法的。因此外层循环必须是引用类型。</p><h3 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a>指针和多维数组</h3><p>程序使用多维数组的名字时也会将其自动转换成指向数组首元素的指针。多维数组名转换得来的指针是指向第一个内层数组的指针。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br><span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">4</span>] = ia;<span class="hljs-comment">//指向的是第一个维度为4的数组</span><br><span class="hljs-built_in">int</span> *ip[<span class="hljs-number">4</span>];<span class="hljs-comment">//整形指针的数组</span><br>p = &amp;ia[<span class="hljs-number">2</span>];<span class="hljs-comment">//指向ia的尾元素</span><br></code></pre></td></tr></table></figure><p>使用auto 或者decltype可以尽可能避免在数组前添加指针类型。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(auto p <span class="hljs-operator">=</span> ia<span class="hljs-comment">; p &lt; end(ia); ++p)&#123;</span><br>    for(auto q <span class="hljs-operator">=</span> *p<span class="hljs-comment">; q &lt; end(*p); q++)</span><br>        cout &lt;&lt; *q &lt;&lt; <span class="hljs-string">&quot; &quot;</span><span class="hljs-comment">;</span><br>    cout &lt;&lt; endl<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型别名简化多维数组的指针"><a href="#类型别名简化多维数组的指针" class="headerlink" title="类型别名简化多维数组的指针"></a>类型别名简化多维数组的指针</h3><p>将四个整数组成的数组类型命名为int_array。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">using <span class="hljs-built_in">int</span>_array = <span class="hljs-built_in">int</span>[<span class="hljs-number">4</span>];<span class="hljs-comment">//C11的类型别名声明</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span>_array[<span class="hljs-number">4</span>];<span class="hljs-comment">//等价的typedef声明</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span>_array *p = ia; p! = ia + <span class="hljs-number">3</span>; ++p)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> *q = *p; q!= *p + <span class="hljs-number">4</span>; ++q)<br>        cout &lt;&lt; *q &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c++primer第二章笔记</title>
    <link href="/2025/01/15/c++primer%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/15/c++primer%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>用于个人学习笔记使用,可能会存在许多错误与模糊的地方。</p><span id="more"></span><h1 id="二-基础变量和类型"><a href="#二-基础变量和类型" class="headerlink" title="二.基础变量和类型"></a>二.基础变量和类型</h1><h2 id="基础变量"><a href="#基础变量" class="headerlink" title="基础变量"></a>基础变量</h2><p>浮点数字面值<br>3.14159 或 3.14159E0,其中E0为科学计数法表示指数,E0表示指数为0。</p><p>C++规定的转义序列:<br>换行符\n    横向制表符\t    报警(响铃)符\a  反斜线\    回车符\r    略</p><p>Latin-1字符集<br>(3位八进制数或X+多个六进制数)</p><p>L’a’宽字符型字面值 wchar_t<br>3.14159L long double</p><p>对象是指一块能存储数据并具有某种类型的内存空间。</p><p>C++中初始化不等同于赋值。</p><p>int a{ld}列表初始化。<br>列表初始化存在丢失信息的风险时将会报错。</p><p>&#x2F;&#x2F;page 67</p><h2 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用即别名,引用非对象。<br>引用的使用:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">int <span class="hljs-meta">&amp;j;<span class="hljs-comment">//error</span></span><br>int <span class="hljs-meta">&amp;j = 1;<span class="hljs-comment">//error </span></span><br>int <span class="hljs-meta">&amp;i = j;</span><br>i = <span class="hljs-number">1</span>;<span class="hljs-comment">//j = 1;</span><br></code></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针指向对象, 引用非对象,因此无法定义指向对象的指针。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> ival = <span class="hljs-number">42</span>;<br><span class="hljs-built_in">int</span> *p = &amp;ival;<span class="hljs-comment">//&amp;为取地址符</span><br>cout &lt;&lt; *p;<span class="hljs-comment">//&amp;为解引用符,输出p指针指向地址上的内容</span><br></code></pre></td></tr></table></figure><p>C++11以后,空指针最好用nullptr而非NULL,尽量初始化所有的指针。<br>如果指针具有合法值,就能在条件表达式当中采用算术值为条件。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span> = <span class="hljs-number">1024</span>;<br><span class="hljs-built_in">int</span> *pi = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> *pi2 = &amp;<span class="hljs-keyword">val</span>;<br><span class="hljs-keyword">if</span>(pi)<span class="hljs-comment">//false</span><br><span class="hljs-keyword">if</span>(pi2)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>void* 指针</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">int* <span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>;<br>int *<span class="hljs-selector-tag">A</span>, *<span class="hljs-selector-tag">B</span>;<br></code></pre></td></tr></table></figure><h3 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h3><p>一旦定义了引用,就无法令其再绑定到另外的对象,之后每次使用那个引用都是访问它最初绑定的对象。</p><p>引用本身不是一个对象,但是指向引用的指针是一个对象,因此可以引用指向引用的指针。如</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> *<span class="hljs-built_in">ip</span>, &amp;i = <span class="hljs-built_in">ip</span><span class="hljs-comment">;//i为ip指针的引用</span><br></code></pre></td></tr></table></figure><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>const可以将一个变量的类型加以限定。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const int i <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>默认情况下,const仅文件内有效。对于const变脸的声明与定义添加extern关键字就可以只用定义一次:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> bufsize = <span class="hljs-built_in">fcn</span>();<span class="hljs-comment">//定义并初始化</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> bufsize;<span class="hljs-comment">//头文件</span><br></code></pre></td></tr></table></figure><h3 id="引用与const"><a href="#引用与const" class="headerlink" title="引用与const"></a>引用与const</h3><p>const也可以进行引用</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> i = <span class="hljs-number">10086</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> &amp;<span class="hljs-keyword">is</span> = i;<br></code></pre></td></tr></table></figure><p>常量引用绑定非常量对象是合法的:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> a = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> &amp;a1 = a;<br></code></pre></td></tr></table></figure><p>这个操作是合法的,然而不允许通过a1改变a的值。如果该变量可以转换成const对应的类型,则编译器会生成一个临时量来实现对象的绑定。其间编译器会将上述代码变为以下形式:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> temp = a;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> &amp;a1 = temp;<br></code></pre></td></tr></table></figure><h3 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h3><p>指向常量的指针(pointer to const)不能改变其所指向对象的值,但是可以指向常量。它会“自以为”指向了一个常量。普通变量指针不能指向常量:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> pi = <span class="hljs-number">3.14</span>;<br><span class="hljs-built_in">double</span> pp = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span>* p1 = &amp;pi, p2 = &amp;pp;<span class="hljs-comment">//合法</span><br><span class="hljs-built_in">double</span> *p0 = &amp;pi;<span class="hljs-comment">//不合法</span><br></code></pre></td></tr></table></figure><p>顶层const:指针本身是常量。底层const:指针所指对象为常量。</p><h2 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h2><p>常量表达式指值不会改变且在编译过程就能得到计算结果的表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mf = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> m = mf + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> sz = <span class="hljs-built_in">size</span>();<span class="hljs-comment">//size定义为constexpr函数才是正确的声明语句</span><br></code></pre></td></tr></table></figure><p>constex将变量认定为一个常量表达式,声明为constexpr的变量初始值一定是常量,且constexpr函数也应该足够简单,所以可以在编译环节就能获取到。constexpr指针初始值只能为nullptr或者0,或者是存储与某个固定地址中的对象。</p><h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> wages;<span class="hljs-comment">//传统方法</span><br><span class="hljs-keyword">using</span> SI =  Sales_items;<span class="hljs-comment">//别名声明</span><br></code></pre></td></tr></table></figure><h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>auto让编译器来分析表达式所属于的类型,auto初始化中所有变量的基本数据类型必须一样。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span> item = val1 + val2;<span class="hljs-comment">//item会根据val1和val的类型来自动确定变量类型。</span><br><span class="hljs-built_in">auto</span> i = <span class="hljs-number">0</span>, *p = &amp;i;<span class="hljs-comment">//正确</span><br><span class="hljs-built_in">auto</span> j = <span class="hljs-number">0</span>, pi = <span class="hljs-number">3.14</span>;<span class="hljs-comment">//错误 </span><br></code></pre></td></tr></table></figure><h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>decltype允许变量通过操作数确定变量的类型,但是却不实际计算表达式的值。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">decltype(<span class="hljs-built_in">f</span>()) <span class="hljs-keyword">sum</span> = x; <span class="hljs-comment">//sum的类型为f()返回的类型</span><br></code></pre></td></tr></table></figure><p>此时编译器只会调用f()的返回值类型,并不会完整调用f()函数。如果操作数的类型是一个常量的话,需要进行初始化。<br>当操作数为引用时,decltype()的结果也将会是引用类型。若想让结果类型为引用的所指类型,可以将引用作为表达式的一部分。例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>, *p = &amp;i, &amp;r = i;<br><span class="hljs-keyword">decltype</span>(r + <span class="hljs-number">0</span>) b;<br><span class="hljs-keyword">decltype</span>(*p) c;<span class="hljs-comment">//错误, int&amp;需要初始化。</span><br></code></pre></td></tr></table></figure><p>当表达式内容是解引用操作时,decltype将会得到引用类型。<br>在decltype中,变量名不加括号将会得到变量的类型,如果加上一层或多层,就会被视作表达式,变量是一种可以作为赋值语句左值的特殊表达式,此时decltype得到引用类型。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">decltype</span>((i)) d;<span class="hljs-comment">//int&amp;,此时是引用类型,需要初始化</span><br><span class="hljs-built_in">decltype</span>(i) e;<span class="hljs-comment">//int</span><br></code></pre></td></tr></table></figure><p>双层括号的情况下,得到的结果永远是引用,单层括号只有在操作数本身是一个引用时才会是引用。</p><blockquote><p>头文件：#include<typeinfo><br>获取变量类型名称: typeid(变量).name()<br>返回值取决于编辑器</p></blockquote><p>练习题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">decltype</span>(a) c = a;<br>    <span class="hljs-keyword">decltype</span>(a = b) d = a;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;a(&quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(a).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;)=&quot;</span> &lt;&lt; a &lt;&lt;std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;b(&quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(b).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;)=&quot;</span> &lt;&lt; b &lt;&lt;std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;c(&quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(c).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;)=&quot;</span> &lt;&lt; c &lt;&lt;std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;d(&quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(d).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;)=&quot;</span> &lt;&lt; d &lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//a = 4(int), b = 4(int), c = 4(int) d = 4(int);</span><br>    其中(a = b)返回的是对a的左值引用，因此d是引用类型。<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="auto与decltype的区别"><a href="#auto与decltype的区别" class="headerlink" title="auto与decltype的区别"></a>auto与decltype的区别</h3><table><thead><tr><th align="left">特性</th><th align="center">decltype</th><th align="center">auto</th></tr></thead><tbody><tr><td align="left">用法</td><td align="center">推导表达式类型，<strong>不进行初始化</strong></td><td align="center">推导变量类型，<strong>进行初始化</strong></td></tr><tr><td align="left">推导依据</td><td align="center">基于表达式或变量的静态类型</td><td align="center">基于初始化表达式的实际类型</td></tr><tr><td align="left">适用范围</td><td align="center">用于任何表达式</td><td align="center">仅可用于变量</td></tr><tr><td align="left">引用与修饰符</td><td align="center">可<strong>保留引用与const修饰符</strong></td><td align="center">通常<strong>忽略顶层const和引用修饰符</strong></td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">42</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) a = (x);<span class="hljs-comment">//a为&amp;int</span><br><span class="hljs-keyword">auto</span> b = (x);<span class="hljs-comment">//b为int</span><br></code></pre></td></tr></table></figure><h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><h3 id="简单类的初步定义"><a href="#简单类的初步定义" class="headerlink" title="简单类的初步定义"></a>简单类的初步定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sales_data</span>&#123;<br>    std:: string bookIbsn;<br>    <span class="hljs-type">unsigned</span> sold_num = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0</span>;<br>&#125;;<span class="hljs-comment">//没有初始值的成员将会被默认初始化</span><br>Sakes_data accum, trans, *salesptr;<span class="hljs-comment">//类与对象的定义也可以放一起写</span><br></code></pre></td></tr></table></figure><h3 id="使用类"><a href="#使用类" class="headerlink" title="使用类"></a>使用类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Sales_data.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Sales_data data1, data2;<br>    <span class="hljs-type">int</span> price;<br>    std::cin &gt;&gt; data1.bookIbsn &gt;&gt; data1.sold_num &gt;&gt; price;<br>    data1.revenue = price * data1.sold_num;<br>    std::cin &gt;&gt; data2.bookIbsn &gt;&gt; data2.sold_num &gt;&gt; price;<br>    data2.revenue = price * data2.sold_num;<span class="hljs-comment">//分别计算两个对象的总金额</span><br>    <span class="hljs-keyword">if</span>(data1.bookIbsn == data2.bookIbsn)&#123;<span class="hljs-comment">//判断是否为相同的IBSN</span><br>        <span class="hljs-type">unsigned</span> totalcnt = data1.sold_num + data2.sold_num;<br>        <span class="hljs-type">double</span> totalrevenue = data1.revenue + data2.revenue;<br>        <span class="hljs-keyword">if</span>(totalcnt != <span class="hljs-number">0</span>)<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Sold &quot;</span> &lt;&lt; totalcnt &lt;&lt; std::endl &lt;&lt;<span class="hljs-string">&quot;Earned a total of &quot;</span>&lt;&lt; totalrevenue &lt;&lt; std::endl;<br>        <span class="hljs-keyword">else</span><br>           std::cout &lt;&lt; <span class="hljs-string">&quot;No sales&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Data should refer to the same Ibsn&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-comment">//处理错误情况</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编写头文件"><a href="#编写头文件" class="headerlink" title="编写头文件"></a>编写头文件</h3><p>头文件保护符依赖于预处理变量。当变量已定义#ifdef为真,变量未定义时#ifndef为真;再用#define将名称设置为预处理变量,检查结果为真将会执行后续操作直到#endif为止。这样可以避免重复包含的发生。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SALES_DATA_H <span class="hljs-comment">//未定义是为真</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SALES_DATA_H <span class="hljs-comment">//定义防止重复包含该头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sales_data</span> &#123;<br>    std::string bookIbsn;<br>    <span class="hljs-type">unsigned</span> sold_num = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//执行到#endif</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客更新</title>
    <link href="/2025/01/08/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%202025.1.8/"/>
    <url>/2025/01/08/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%202025.1.8/</url>
    
    <content type="html"><![CDATA[<p>在忙了一段时间后，花了一下午捣鼓了blog。</p><span id="more"></span><h3 id="页面头图更换"><a href="#页面头图更换" class="headerlink" title="页面头图更换"></a>页面头图更换</h3><p>将页面头图换成了暗喻幻想中的旅途画卷。在游玩的时候就感觉印象深刻，这个地方atlus做的还是非常好的，非常的好看。</p><h3 id="评论功能的实现"><a href="#评论功能的实现" class="headerlink" title="评论功能的实现"></a>评论功能的实现</h3><p>在折腾了快两个小时gitalk无果之后选择了<a href="https://github.com/apps/utterances">Utterances</a>。<br>安装Utterances app后，在GitHub端配置选择Repository的用户名和仓库名称（blog的仓库，例如我的是 meltlis&#x2F;meltlis.github.io），之后依次是issues与posts的映射关系还有评论的issues的label，全部默认就行。最后就是选择喜好的Theme。<br>最后在本地_config.yml对照配置就完成了。记得将comments enable并选择Utterances。<br>配置如下:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">utterances:</span><br><span class="hljs-symbol">  repo:</span> (YourUserName/YourRepositoryName)<br><span class="hljs-symbol">  issue_term:</span> pathname<br><span class="hljs-symbol">  label:</span> utterances<br><span class="hljs-symbol">  theme:</span> github-light<br><span class="hljs-symbol">  theme_dark:</span> github-dark<br></code></pre></td></tr></table></figure><h3 id="未来可能的友联"><a href="#未来可能的友联" class="headerlink" title="未来可能的友联"></a>未来可能的友联</h3><p>依照Fluid文档完成了折跃门部分，可以找博客主索要或者互加友联。</p><h3 id="关于页完善"><a href="#关于页完善" class="headerlink" title="关于页完善"></a>关于页完善</h3><p>依照Fluid文档完成了关于页的简介。</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>网站</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>每日一题2025-1-1</title>
    <link href="/2025/01/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%202025.1.1/"/>
    <url>/2025/01/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%202025.1.1/</url>
    
    <content type="html"><![CDATA[<p>新年第一题，难度简单，虽然不知道二进制的库函数但手搓秒了。  </p><span id="more"></span><p><a href="https://leetcode.cn/problems/convert-date-to-binary/description/" title="跳转至题目">3280.将日期转换为二进制表示</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convertDateToBinary</span><span class="hljs-params">(string date)</span> </span>&#123;<br>        string return_date, temp;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, num, len = date.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br>            num = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (i &lt; len &amp;&amp; date[i] != <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>                num = num * <span class="hljs-number">10</span> + (date[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>                ++i;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(num &gt; <span class="hljs-number">0</span>)&#123;<br>                temp += (num % <span class="hljs-number">2</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>                num /= <span class="hljs-number">2</span>;<br>            &#125;   <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = temp.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; k &gt;=<span class="hljs-number">0</span>; k--)&#123;<br>                return_date += temp[k];<br>            &#125;<br>            temp = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">if</span> (j != <span class="hljs-number">2</span>)&#123;<br>                return_date += <span class="hljs-string">&#x27;-&#x27;</span>;<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> return_date;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/image/lc20250101.png" alt="图片" title="结果"></p>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>leetcode</category>
      
      <category>简单</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客上线</title>
    <link href="/2024/12/31/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF/"/>
    <url>/2024/12/31/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>meltlis搭建的博客已经悄悄上线了！现已挂载在GitHub上。  </p><span id="more"></span><p>总之在2025年以前能够在互联网上看到这篇文章了！<br>目前这里什么都没有。</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>网站</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL unordered,个人理解总结</title>
    <link href="/2024/01/30/Cpp%E5%AE%B9%E5%99%A8/"/>
    <url>/2024/01/30/Cpp%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>很早以前写的。  </p><span id="more"></span><h2 id="1-unordered-set-amp-unoderded-map"><a href="#1-unordered-set-amp-unoderded-map" class="headerlink" title="1.unordered_set &amp; unoderded_map"></a>1.unordered_set &amp; unoderded_map</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">unordered_set</span>(<span class="hljs-built_in">int</span>(hashvalue))hashname<br></code></pre></td></tr></table></figure><p>仅存储value不存储key(&#x3D;0or1)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">unordered_map</span>(<span class="hljs-built_in">int</span>(hashkey),<span class="hljs-built_in">int</span>(hashvalue))hashname<br></code></pre></td></tr></table></figure><p>存储value与key</p><h4 id="使用例-力扣第2670题"><a href="#使用例-力扣第2670题" class="headerlink" title="使用例 力扣第2670题"></a>使用例 力扣第2670题</h4><blockquote><p>给你一个下标从 0 开始的数组 nums ，数组长度为 n 。<br>nums 的 不同元素数目差 数组可以用一个长度为 n 的数组 diff 表示，其中 diff[i] 等于前缀 nums[0, …, i] 中不同元素的数目 减去 后缀 nums[i + 1, …, n - 1] 中不同元素的数目。<br>返回 nums 的 不同元素数目差 数组。<br>注意 nums[i, …, j] 表示 nums 的一个从下标 i 开始到下标 j 结束的子数组（包含下标 i 和 j 对应元素）。特别需要说明的是，如果 i &gt; j ，则 nums[i, …, j] 表示一个空子数组。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distinctDifferenceArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i, j, len = nums.<span class="hljs-built_in">size</span>(), a =<span class="hljs-number">0</span>;<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; nums1;<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; nums2;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(len)</span></span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!nums2[nums[i]])&#123;<br>            nums2[nums[i]]++;<br>            a--;<br>        &#125;<br>        <span class="hljs-keyword">else</span> nums2[nums[i]]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums2[nums[i]])&#123;<br>            nums2[nums[i]]--;<br>            <span class="hljs-keyword">if</span>(!nums2[nums[i]])a++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!nums1[nums[i]])&#123;<br>            a++;<br>            nums1[nums[i]]++;<br>        &#125;<br>        ans[i] = a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distinctDifferenceArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i, j, len = nums.<span class="hljs-built_in">size</span>(), a = <span class="hljs-number">0</span>;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; num;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(len,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(i = len <span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; --i)&#123;<br>        num.<span class="hljs-built_in">insert</span>(nums[i]);<br>        ans[i - <span class="hljs-number">1</span>] -= num.<span class="hljs-built_in">size</span>();<br>    &#125;<br>    num.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>        num.<span class="hljs-built_in">insert</span>(nums[i]);<br>        ans[i] += num.<span class="hljs-built_in">size</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-operator-与-at-方法的区别"><a href="#2-operator-与-at-方法的区别" class="headerlink" title="2.operator()与.at()方法的区别"></a>2.operator()与.at()方法的区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout&lt;&lt;hashname[hashkey]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;hashname.<span class="hljs-built_in">at</span>(hashkey);<br></code></pre></td></tr></table></figure><p>都用于输出输出hash对应key的值。区别在于当key不存在时，at()会抛出了超出范围的异常，而operator []会用默认值进行初始化，例<code>hashname.at(noexisthashkey); //error hashname[noexisthashkey];</code> 创建一个值为默认值0，键为noexisthashkey的对</p><h2 id="3-auto-amp-a-b-：n与auto-amp-n-pair"><a href="#3-auto-amp-a-b-：n与auto-amp-n-pair" class="headerlink" title="3.auto&amp;[a, b]：n与auto&amp; n:pair"></a>3.auto&amp;[a, b]：n与auto&amp; n:pair</h2><p><code>for(auto&amp;[a, b]:n)</code>与<code>for(auto&amp; n:pair)</code>均为遍历键对。<br>前者a为键，b为键值。而后者通过n.first访问键，n.second访问键值</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
