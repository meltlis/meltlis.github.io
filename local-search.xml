<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>c++primer第二章笔记</title>
    <link href="/2025/01/15/c-primer%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/15/c-primer%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>用于个人学习笔记使用,可能会存在许多错误与模糊的地方。</p><span id="more"></span><h1 id="二-基础变量和类型"><a href="#二-基础变量和类型" class="headerlink" title="二.基础变量和类型"></a>二.基础变量和类型</h1><h2 id="基础变量"><a href="#基础变量" class="headerlink" title="基础变量"></a>基础变量</h2><p>浮点数字面值<br>3.14159 或 3.14159E0,其中E0为科学计数法表示指数,E0表示指数为0。</p><p>C++规定的转义序列:<br>换行符\n    横向制表符\t    报警(响铃)符\a  反斜线\    回车符\r    略</p><p>Latin-1字符集<br>(3位八进制数或X+多个六进制数)</p><p>L’a’宽字符型字面值 wchar_t<br>3.14159L long double</p><p>对象是指一块能存储数据并具有某种类型的内存空间。</p><p>C++中初始化不等同于赋值。</p><p>int a{ld}列表初始化。<br>列表初始化存在丢失信息的风险时将会报错。</p><p>&#x2F;&#x2F;page 67</p><h2 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用即别名,引用非对象。<br>引用的使用:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">int <span class="hljs-meta">&amp;j;<span class="hljs-comment">//error</span></span><br>int <span class="hljs-meta">&amp;j = 1;<span class="hljs-comment">//error </span></span><br>int <span class="hljs-meta">&amp;i = j;</span><br>i = <span class="hljs-number">1</span>;<span class="hljs-comment">//j = 1;</span><br></code></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针指向对象, 引用非对象,因此无法定义指向对象的指针。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> ival = <span class="hljs-number">42</span>;<br><span class="hljs-built_in">int</span> *p = &amp;ival;<span class="hljs-comment">//&amp;为取地址符</span><br>cout &lt;&lt; *p;<span class="hljs-comment">//&amp;为解引用符,输出p指针指向地址上的内容</span><br></code></pre></td></tr></table></figure><p>C++11以后,空指针最好用nullptr而非NULL,尽量初始化所有的指针。<br>如果指针具有合法值,就能在条件表达式当中采用算术值为条件。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span> = <span class="hljs-number">1024</span>;<br><span class="hljs-built_in">int</span> *pi = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> *pi2 = &amp;<span class="hljs-keyword">val</span>;<br><span class="hljs-keyword">if</span>(pi)<span class="hljs-comment">//false</span><br><span class="hljs-keyword">if</span>(pi2)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>void* 指针</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">int* <span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>;<br>int *<span class="hljs-selector-tag">A</span>, *<span class="hljs-selector-tag">B</span>;<br></code></pre></td></tr></table></figure><h3 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h3><p>一旦定义了引用,就无法令其再绑定到另外的对象,之后每次使用那个引用都是访问它最初绑定的对象。</p><p>引用本身不是一个对象,但是指向引用的指针是一个对象,因此可以引用指向引用的指针。如</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> *<span class="hljs-built_in">ip</span>, &amp;i = <span class="hljs-built_in">ip</span><span class="hljs-comment">;//i为ip指针的引用</span><br></code></pre></td></tr></table></figure><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>const可以将一个变量的类型加以限定。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const int i <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>默认情况下,const仅文件内有效。对于const变脸的声明与定义添加extern关键字就可以只用定义一次:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> bufsize = <span class="hljs-built_in">fcn</span>();<span class="hljs-comment">//定义并初始化</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> bufsize;<span class="hljs-comment">//头文件</span><br></code></pre></td></tr></table></figure><h3 id="引用与const"><a href="#引用与const" class="headerlink" title="引用与const"></a>引用与const</h3><p>const也可以进行引用</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> i = <span class="hljs-number">10086</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> &amp;<span class="hljs-keyword">is</span> = i;<br></code></pre></td></tr></table></figure><p>常量引用绑定非常量对象是合法的:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> a = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> &amp;a1 = a;<br></code></pre></td></tr></table></figure><p>这个操作是合法的,然而不允许通过a1改变a的值。如果该变量可以转换成const对应的类型,则编译器会生成一个临时量来实现对象的绑定。其间编译器会将上述代码变为以下形式:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> temp = a;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> &amp;a1 = temp;<br></code></pre></td></tr></table></figure><h3 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h3><p>指向常量的指针(pointer to const)不能改变其所指向对象的值,但是可以指向常量。它会“自以为”指向了一个常量。普通变量指针不能指向常量:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> pi = <span class="hljs-number">3.14</span>;<br><span class="hljs-built_in">double</span> pp = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span>* p1 = &amp;pi, p2 = &amp;pp;<span class="hljs-comment">//合法</span><br><span class="hljs-built_in">double</span> *p0 = &amp;pi;<span class="hljs-comment">//不合法</span><br></code></pre></td></tr></table></figure><p>顶层const:指针本身是常量。底层const:指针所指对象为常量。</p><h2 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h2><p>常量表达式指值不会改变且在编译过程就能得到计算结果的表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mf = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> m = mf + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> sz = <span class="hljs-built_in">size</span>();<span class="hljs-comment">//size定义为constexpr函数才是正确的声明语句</span><br></code></pre></td></tr></table></figure><p>constex将变量认定为一个常量表达式,声明为constexpr的变量初始值一定是常量,且constexpr函数也应该足够简单,所以可以在编译环节就能获取到。constexpr指针初始值只能为nullptr或者0,或者是存储与某个固定地址中的对象。</p><h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> wages;<span class="hljs-comment">//传统方法</span><br><span class="hljs-keyword">using</span> SI =  Sales_items;<span class="hljs-comment">//别名声明</span><br></code></pre></td></tr></table></figure><h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>auto让编译器来分析表达式所属于的类型,auto初始化中所有变量的基本数据类型必须一样。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span> item = val1 + val2;<span class="hljs-comment">//item会根据val1和val的类型来自动确定变量类型。</span><br><span class="hljs-built_in">auto</span> i = <span class="hljs-number">0</span>, *p = &amp;i;<span class="hljs-comment">//正确</span><br><span class="hljs-built_in">auto</span> j = <span class="hljs-number">0</span>, pi = <span class="hljs-number">3.14</span>;<span class="hljs-comment">//错误 </span><br></code></pre></td></tr></table></figure><h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>decltype允许变量通过操作数确定变量的类型,但是却不实际计算表达式的值。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">decltype(<span class="hljs-built_in">f</span>()) <span class="hljs-keyword">sum</span> = x; <span class="hljs-comment">//sum的类型为f()返回的类型</span><br></code></pre></td></tr></table></figure><p>此时编译器只会调用f()的返回值类型,并不会完整调用f()函数。如果操作数的类型是一个常量的话,需要进行初始化。<br>当操作数为引用时,decltype()的结果也将会是引用类型。若想让结果类型为引用的所指类型,可以将引用作为表达式的一部分。例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>, *p = &amp;i, &amp;r = i;<br><span class="hljs-keyword">decltype</span>(r + <span class="hljs-number">0</span>) b;<br><span class="hljs-keyword">decltype</span>(*p) c;<span class="hljs-comment">//错误, int&amp;需要初始化。</span><br></code></pre></td></tr></table></figure><p>当表达式内容是解引用操作时,decltype将会得到引用类型。<br>在decltype中,变量名不加括号将会得到变量的类型,如果加上一层或多层,就会被视作表达式,变量是一种可以作为赋值语句左值的特殊表达式,此时decltype得到引用类型。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">decltype</span>((i)) d;<span class="hljs-comment">//int&amp;,此时是引用类型,需要初始化</span><br><span class="hljs-built_in">decltype</span>(i) e;<span class="hljs-comment">//int</span><br></code></pre></td></tr></table></figure><p>双层括号的情况下,得到的结果永远是引用,单层括号只有在操作数本身是一个引用时才会是引用。</p><blockquote><p>头文件：#include<typeinfo><br>获取变量类型名称: typeid(变量).name()<br>返回值取决于编辑器</p></blockquote><p>练习题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">decltype</span>(a) c = a;<br>    <span class="hljs-keyword">decltype</span>(a = b) d = a;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;a(&quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(a).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;)=&quot;</span> &lt;&lt; a &lt;&lt;std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;b(&quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(b).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;)=&quot;</span> &lt;&lt; b &lt;&lt;std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;c(&quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(c).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;)=&quot;</span> &lt;&lt; c &lt;&lt;std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;d(&quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(d).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;)=&quot;</span> &lt;&lt; d &lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//a = 4(int), b = 4(int), c = 4(int) d = 4(int);</span><br>    其中(a = b)返回的是对a的左值引用，因此d是引用类型。<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="auto与decltype的区别"><a href="#auto与decltype的区别" class="headerlink" title="auto与decltype的区别"></a>auto与decltype的区别</h3><table><thead><tr><th align="left">特性</th><th align="center">decltype</th><th align="center">auto</th></tr></thead><tbody><tr><td align="left">用法</td><td align="center">推导表达式类型，<strong>不进行初始化</strong></td><td align="center">推导变量类型，<strong>进行初始化</strong></td></tr><tr><td align="left">推导依据</td><td align="center">基于表达式或变量的静态类型</td><td align="center">基于初始化表达式的实际类型</td></tr><tr><td align="left">适用范围</td><td align="center">用于任何表达式</td><td align="center">仅可用于变量</td></tr><tr><td align="left">引用与修饰符</td><td align="center">可<strong>保留引用与const修饰符</strong></td><td align="center">通常<strong>忽略顶层const和引用修饰符</strong></td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">42</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) a = (x);<span class="hljs-comment">//a为&amp;int</span><br><span class="hljs-keyword">auto</span> b = (x);<span class="hljs-comment">//b为int</span><br></code></pre></td></tr></table></figure><h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><h3 id="简单类的初步定义"><a href="#简单类的初步定义" class="headerlink" title="简单类的初步定义"></a>简单类的初步定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sales_data</span>&#123;<br>    std:: string bookIbsn;<br>    <span class="hljs-type">unsigned</span> sold_num = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0</span>;<br>&#125;;<span class="hljs-comment">//没有初始值的成员将会被默认初始化</span><br>Sakes_data accum, trans, *salesptr;<span class="hljs-comment">//类与对象的定义也可以放一起写</span><br></code></pre></td></tr></table></figure><h3 id="使用类"><a href="#使用类" class="headerlink" title="使用类"></a>使用类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Sales_data.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Sales_data data1, data2;<br>    <span class="hljs-type">int</span> price;<br>    std::cin &gt;&gt; data1.bookIbsn &gt;&gt; data1.sold_num &gt;&gt; price;<br>    data1.revenue = price * data1.sold_num;<br>    std::cin &gt;&gt; data2.bookIbsn &gt;&gt; data2.sold_num &gt;&gt; price;<br>    data2.revenue = price * data2.sold_num;<span class="hljs-comment">//分别计算两个对象的总金额</span><br>    <span class="hljs-keyword">if</span>(data1.bookIbsn == data2.bookIbsn)&#123;<span class="hljs-comment">//判断是否为相同的IBSN</span><br>        <span class="hljs-type">unsigned</span> totalcnt = data1.sold_num + data2.sold_num;<br>        <span class="hljs-type">double</span> totalrevenue = data1.revenue + data2.revenue;<br>        <span class="hljs-keyword">if</span>(totalcnt != <span class="hljs-number">0</span>)<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Sold &quot;</span> &lt;&lt; totalcnt &lt;&lt; std::endl &lt;&lt;<span class="hljs-string">&quot;Earned a total of &quot;</span>&lt;&lt; totalrevenue &lt;&lt; std::endl;<br>        <span class="hljs-keyword">else</span><br>           std::cout &lt;&lt; <span class="hljs-string">&quot;No sales&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Data should refer to the same Ibsn&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-comment">//处理错误情况</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编写头文件"><a href="#编写头文件" class="headerlink" title="编写头文件"></a>编写头文件</h3><p>头文件保护符依赖于预处理变量。当变量已定义#ifdef为真,变量未定义时#ifndef为真;再用#define将名称设置为预处理变量,检查结果为真将会执行后续操作直到#endif为止。这样可以避免重复包含的发生。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SALES_DATA_H <span class="hljs-comment">//未定义是为真</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SALES_DATA_H <span class="hljs-comment">//定义防止重复包含该头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sales_data</span> &#123;<br>    std::string bookIbsn;<br>    <span class="hljs-type">unsigned</span> sold_num = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//执行到#endif</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客更新</title>
    <link href="/2025/01/08/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%202025.1.8/"/>
    <url>/2025/01/08/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%202025.1.8/</url>
    
    <content type="html"><![CDATA[<p>在忙了一段时间后，花了一下午捣鼓了blog。</p><span id="more"></span><h3 id="页面头图更换"><a href="#页面头图更换" class="headerlink" title="页面头图更换"></a>页面头图更换</h3><p>将页面头图换成了暗喻幻想中的旅途画卷。在游玩的时候就感觉印象深刻，这个地方atlus做的还是非常好的，非常的好看。</p><h3 id="评论功能的实现"><a href="#评论功能的实现" class="headerlink" title="评论功能的实现"></a>评论功能的实现</h3><p>在折腾了快两个小时gitalk无果之后选择了<a href="https://github.com/apps/utterances">Utterances</a>。<br>安装Utterances app后，在GitHub端配置选择Repository的用户名和仓库名称（blog的仓库，例如我的是 meltlis&#x2F;meltlis.github.io），之后依次是issues与posts的映射关系还有评论的issues的label，全部默认就行。最后就是选择喜好的Theme。<br>最后在本地_config.yml对照配置就完成了。记得将comments enable并选择Utterances。<br>配置如下:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">utterances:</span><br><span class="hljs-symbol">  repo:</span> (YourUserName/YourRepositoryName)<br><span class="hljs-symbol">  issue_term:</span> pathname<br><span class="hljs-symbol">  label:</span> utterances<br><span class="hljs-symbol">  theme:</span> github-light<br><span class="hljs-symbol">  theme_dark:</span> github-dark<br></code></pre></td></tr></table></figure><h3 id="未来可能的友联"><a href="#未来可能的友联" class="headerlink" title="未来可能的友联"></a>未来可能的友联</h3><p>依照Fluid文档完成了折跃门部分，可以找博客主索要或者互加友联。</p><h3 id="关于页完善"><a href="#关于页完善" class="headerlink" title="关于页完善"></a>关于页完善</h3><p>依照Fluid文档完成了关于页的简介。</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>网站</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>每日一题2025-1-1</title>
    <link href="/2025/01/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%202025.1.1/"/>
    <url>/2025/01/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%202025.1.1/</url>
    
    <content type="html"><![CDATA[<p>新年第一题，难度简单，虽然不知道二进制的库函数但手搓秒了。  </p><span id="more"></span><p><a href="https://leetcode.cn/problems/convert-date-to-binary/description/" title="跳转至题目">3280.将日期转换为二进制表示</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convertDateToBinary</span><span class="hljs-params">(string date)</span> </span>&#123;<br>        string return_date, temp;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, num, len = date.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br>            num = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (i &lt; len &amp;&amp; date[i] != <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>                num = num * <span class="hljs-number">10</span> + (date[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>                ++i;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(num &gt; <span class="hljs-number">0</span>)&#123;<br>                temp += (num % <span class="hljs-number">2</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>                num /= <span class="hljs-number">2</span>;<br>            &#125;   <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = temp.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; k &gt;=<span class="hljs-number">0</span>; k--)&#123;<br>                return_date += temp[k];<br>            &#125;<br>            temp = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">if</span> (j != <span class="hljs-number">2</span>)&#123;<br>                return_date += <span class="hljs-string">&#x27;-&#x27;</span>;<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> return_date;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/image/lc20250101.png" alt="图片" title="结果"></p>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>leetcode</category>
      
      <category>简单</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客上线</title>
    <link href="/2024/12/31/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF/"/>
    <url>/2024/12/31/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>meltlis搭建的博客已经悄悄上线了！现已挂载在GitHub上。  </p><span id="more"></span><p>总之在2025年以前能够在互联网上看到这篇文章了！<br>目前这里什么都没有。</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>网站</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL unordered,个人理解总结</title>
    <link href="/2024/01/30/Cpp%E5%AE%B9%E5%99%A8/"/>
    <url>/2024/01/30/Cpp%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>很早以前写的。  </p><span id="more"></span><h2 id="1-unordered-set-amp-unoderded-map"><a href="#1-unordered-set-amp-unoderded-map" class="headerlink" title="1.unordered_set &amp; unoderded_map"></a>1.unordered_set &amp; unoderded_map</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">unordered_set</span>(<span class="hljs-built_in">int</span>(hashvalue))hashname<br></code></pre></td></tr></table></figure><p>仅存储value不存储key(&#x3D;0or1)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">unordered_map</span>(<span class="hljs-built_in">int</span>(hashkey),<span class="hljs-built_in">int</span>(hashvalue))hashname<br></code></pre></td></tr></table></figure><p>存储value与key</p><h4 id="使用例-力扣第2670题"><a href="#使用例-力扣第2670题" class="headerlink" title="使用例 力扣第2670题"></a>使用例 力扣第2670题</h4><blockquote><p>给你一个下标从 0 开始的数组 nums ，数组长度为 n 。<br>nums 的 不同元素数目差 数组可以用一个长度为 n 的数组 diff 表示，其中 diff[i] 等于前缀 nums[0, …, i] 中不同元素的数目 减去 后缀 nums[i + 1, …, n - 1] 中不同元素的数目。<br>返回 nums 的 不同元素数目差 数组。<br>注意 nums[i, …, j] 表示 nums 的一个从下标 i 开始到下标 j 结束的子数组（包含下标 i 和 j 对应元素）。特别需要说明的是，如果 i &gt; j ，则 nums[i, …, j] 表示一个空子数组。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distinctDifferenceArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i, j, len = nums.<span class="hljs-built_in">size</span>(), a =<span class="hljs-number">0</span>;<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; nums1;<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; nums2;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(len)</span></span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!nums2[nums[i]])&#123;<br>            nums2[nums[i]]++;<br>            a--;<br>        &#125;<br>        <span class="hljs-keyword">else</span> nums2[nums[i]]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums2[nums[i]])&#123;<br>            nums2[nums[i]]--;<br>            <span class="hljs-keyword">if</span>(!nums2[nums[i]])a++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!nums1[nums[i]])&#123;<br>            a++;<br>            nums1[nums[i]]++;<br>        &#125;<br>        ans[i] = a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distinctDifferenceArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i, j, len = nums.<span class="hljs-built_in">size</span>(), a = <span class="hljs-number">0</span>;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; num;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(len,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(i = len <span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; --i)&#123;<br>        num.<span class="hljs-built_in">insert</span>(nums[i]);<br>        ans[i - <span class="hljs-number">1</span>] -= num.<span class="hljs-built_in">size</span>();<br>    &#125;<br>    num.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>        num.<span class="hljs-built_in">insert</span>(nums[i]);<br>        ans[i] += num.<span class="hljs-built_in">size</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-operator-与-at-方法的区别"><a href="#2-operator-与-at-方法的区别" class="headerlink" title="2.operator()与.at()方法的区别"></a>2.operator()与.at()方法的区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout&lt;&lt;hashname[hashkey]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;hashname.<span class="hljs-built_in">at</span>(hashkey);<br></code></pre></td></tr></table></figure><p>都用于输出输出hash对应key的值。区别在于当key不存在时，at()会抛出了超出范围的异常，而operator []会用默认值进行初始化，例<code>hashname.at(noexisthashkey); //error hashname[noexisthashkey];</code> 创建一个值为默认值0，键为noexisthashkey的对</p><h2 id="3-auto-amp-a-b-：n与auto-amp-n-pair"><a href="#3-auto-amp-a-b-：n与auto-amp-n-pair" class="headerlink" title="3.auto&amp;[a, b]：n与auto&amp; n:pair"></a>3.auto&amp;[a, b]：n与auto&amp; n:pair</h2><p><code>for(auto&amp;[a, b]:n)</code>与<code>for(auto&amp; n:pair)</code>均为遍历键对。<br>前者a为键，b为键值。而后者通过n.first访问键，n.second访问键值</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
